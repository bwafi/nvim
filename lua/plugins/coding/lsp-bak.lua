return {
  --   {
  --     "nvim-lua/plenary.nvim",
  --     lazy = true,
  --   },
  --
  --   {
  --     "neovim/nvim-lspconfig",
  --     event = { "BufReadPost", "BufWritePost", "BufNewFile" },
  --     dependencies = {
  --       "b0o/schemastore.nvim",
  --       "williamboman/mason.nvim",
  --       "williamboman/mason-lspconfig.nvim",
  --       {
  --         "folke/lazydev.nvim",
  --         ft = "lua",
  --         opts = {
  --           library = {
  --             { path = "luvit-meta/library", words = { "vim%.uv" } },
  --           },
  --         },
  --       },
  --       { "Bilal2453/luvit-meta", lazy = true },
  --     },
  --     opts = {
  --       diagnostics = {
  --         underline = true,
  --         update_in_insert = false,
  --         virtual_text = {
  --           spacing = 4,
  --           source = "if_many",
  --           prefix = "●",
  --         },
  --         severity_sort = true,
  --       },
  --     },
  --     config = function()
  --       local on_attach = function(client, bufnr)
  --         -- vim.lsp.handlers["textDocument/hover"] = vim.lsp.with(vim.lsp.handlers.hover, {
  --         --   border = "single",
  --         -- })
  --         -- vim.lsp.handlers["textDocument/signatureHelp"] = vim.lsp.with(vim.lsp.handlers.signature_help, {
  --         --   border = "single",
  --         --   focusable = false,
  --         --   relative = "cursor",
  --         -- })
  --
  --         -- disable semantic token
  --         -- client.server_capabilities.semanticTokensProvider = nil
  --
  --         local nmap = function(keys, func, desc)
  --           if desc then
  --             desc = "LSP: " .. desc
  --           end
  --
  --           vim.keymap.set("n", keys, func, { buffer = bufnr, desc = desc })
  --         end
  --
  --         nmap("<leader>rn", vim.lsp.buf.rename, "Rename")
  --         nmap("<leader>ca", vim.lsp.buf.code_action, "Code Action")
  --
  --         nmap("gd", require("telescope.builtin").lsp_definitions, "Goto Definition")
  --         nmap("gr", require("telescope.builtin").lsp_references, "Goto References")
  --         nmap("gI", require("telescope.builtin").lsp_implementations, "Goto Implementation")
  --         nmap("<leader>D", require("telescope.builtin").lsp_type_definitions, "Type Definition")
  --         nmap("<leader>ss", require("telescope.builtin").lsp_document_symbols, "Document Symbols")
  --         nmap("<leader>ws", require("telescope.builtin").lsp_dynamic_workspace_symbols, "Workspace Symbols")
  --
  --         -- See `:help K` for why this keymaplsp
  --         nmap("K", vim.lsp.buf.hover, "Hover Documentation")
  --         nmap("<leader>wl", function()
  --           print(vim.inspect(vim.lsp.buf.list_workspace_folders()))
  --         end, "Workspace List Folders")
  --       end
  --
  --       vim.api.nvim_create_autocmd("LspAttach", {
  --
  --         group = vim.api.nvim_create_augroup("kickstart-lsp-attach", { clear = true }),
  --
  --         callback = function(event)
  --           local map = function(keys, func, desc)
  --             vim.keymap.set("n", keys, func, { buffer = event.buf, desc = "LSP: " .. desc })
  --           end
  --
  --           -- Jump to the definition of the word under your cursor.
  --           --  This is where a variable was first declared, or where a function is defined, etc.
  --           --  To jump back, press <C-t>.
  --           map("gd", require("telescope.builtin").lsp_definitions, "[G]oto [D]efinition")
  --
  --           -- Find references for the word under your cursor.
  --           map("gr", require("telescope.builtin").lsp_references, "[G]oto [R]eferences")
  --
  --           -- Jump to the implementation of the word under your cursor.
  --           --  Useful when your language has ways of declaring types without an actual implementation.
  --           map("gI", require("telescope.builtin").lsp_implementations, "[G]oto [I]mplementation")
  --
  --           -- Jump to the type of the word under your cursor.
  --           --  Useful when you're not sure what type a variable is and you want to see
  --           --  the definition of its *type*, not where it was *defined*.
  --           map("<leader>D", require("telescope.builtin").lsp_type_definitions, "Type [D]efinition")
  --
  --           -- Fuzzy find all the symbols in your current document.
  --           --  Symbols are things like variables, functions, types, etc.
  --           map("<leader>ds", require("telescope.builtin").lsp_document_symbols, "[D]ocument [S]ymbols")
  --
  --           -- Fuzzy find all the symbols in your current workspace.
  --           --  Similar to document symbols, except searches over your entire project.
  --           map("<leader>ws", require("telescope.builtin").lsp_dynamic_workspace_symbols, "[W]orkspace [S]ymbols")
  --
  --           -- Rename the variable under your cursor.
  --           --  Most Language Servers support renaming across files, etc.
  --           map("<leader>rn", vim.lsp.buf.rename, "[R]e[n]ame")
  --
  --           -- Execute a code action, usually your cursor needs to be on top of an error
  --           -- or a suggestion from your LSP for this to activate.
  --           map("<leader>ca", vim.lsp.buf.code_action, "[C]ode [A]ction")
  --
  --           -- WARN: This is not Goto Definition, this is Goto Declaration.
  --           --  For example, in C this would take you to the header.
  --           map("gD", vim.lsp.buf.declaration, "[G]oto [D]eclaration")
  --
  --           -- The following two autocommands are used to highlight references of the
  --           -- word under your cursor when your cursor rests there for a little while.
  --           --    See `:help CursorHold` for information about when this is executed
  --           --
  --           -- When you move your cursor, the highlights will be cleared (the second autocommand).
  --           local client = vim.lsp.get_client_by_id(event.data.client_id)
  --           if client and client.supports_method(vim.lsp.protocol.Methods.textDocument_documentHighlight) then
  --             local highlight_augroup = vim.api.nvim_create_augroup("kickstart-lsp-highlight", { clear = false })
  --             vim.api.nvim_create_autocmd({ "CursorHold", "CursorHoldI" }, {
  --               buffer = event.buf,
  --               group = highlight_augroup,
  --               callback = vim.lsp.buf.document_highlight,
  --             })
  --
  --             vim.api.nvim_create_autocmd({ "CursorMoved", "CursorMovedI" }, {
  --               buffer = event.buf,
  --               group = highlight_augroup,
  --               callback = vim.lsp.buf.clear_references,
  --             })
  --
  --             vim.api.nvim_create_autocmd("LspDetach", {
  --               group = vim.api.nvim_create_augroup("kickstart-lsp-detach", { clear = true }),
  --               callback = function(event2)
  --                 vim.lsp.buf.clear_references()
  --                 vim.api.nvim_clear_autocmds({ group = "kickstart-lsp-highlight", buffer = event2.buf })
  --               end,
  --             })
  --           end
  --
  --           -- The following code creates a keymap to toggle inlay hints in your
  --           -- code, if the language server you are using supports them
  --           --
  --           -- This may be unwanted, since they displace some of your code
  --           if client and client.supports_method(vim.lsp.protocol.Methods.textDocument_inlayHint) then
  --             map("<leader>th", function()
  --               vim.lsp.inlay_hint.enable(not vim.lsp.inlay_hint.is_enabled({ bufnr = event.buf }))
  --             end, "[T]oggle Inlay [H]ints")
  --           end
  --         end,
  --       })
  --
  --       -- diagnostics
  --       local signs = {
  --         Error = " ",
  --         Warn = " ",
  --         Hint = " ",
  --         Info = " ",
  --       }
  --
  --       for type, icon in pairs(signs) do
  --         local hl = "DiagnosticSign" .. type
  --         vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
  --       end
  --
  --       -- vim.diagnostic.config({
  --       --   signs = true,
  --       --   severity_sort = false,
  --       -- })
  --
  --       require("mason").setup()
  --       require("mason-lspconfig").setup()
  --
  --       local capabilities = vim.lsp.protocol.make_client_capabilities()
  --       capabilities.textDocument.completion.completionItem.snippetSupport = true
  --
  --       capabilities = require("cmp_nvim_lsp").default_capabilities(capabilities)
  --
  --       local mason_lspconfig = require("mason-lspconfig")
  --
  --       local lspconfig = require("lspconfig")
  --
  --       local excluded_servers = { "eslint", "prettierd", "eslint_d" } -- exclude server because server handling with other plugin
  --
  --       mason_lspconfig.setup_handlers({
  --         function(server_name)
  --           -- exclude server because server handling with other plugin
  --           if not vim.tbl_contains(excluded_servers, server_name) then
  --             require("lspconfig")[server_name].setup({
  --               capabilities = capabilities,
  --               on_attach = on_attach,
  --             })
  --           end
  --         end,
  --
  --         -- setting server
  --         ["lua_ls"] = function()
  --           lspconfig.lua_ls.setup({
  --             capabilities = capabilities,
  --             on_attach = on_attach,
  --             seetings = {
  --               Lua = {
  --                 diagnostics = {
  --                   globals = { "vim" },
  --                 },
  --                 workspace = {
  --                   library = {
  --                     [vim.fn.expand("$VIMRUNTIME/lua")] = true,
  --                     [vim.fn.expand("$VIMRUNTIME/lua/vim/lsp")] = true,
  --                     [vim.fn.stdpath("data") .. "/lazy/lazy.nvim/lua/lazy"] = true,
  --                   },
  --                   checkThirdParty = false,
  --                   maxPreload = 100000,
  --                   preloadFileSize = 10000,
  --                 },
  --                 -- telemetry = { enable = false },
  --               },
  --             },
  --           })
  --         end,
  --
  --         ["jsonls"] = function()
  --           lspconfig.jsonls.setup({
  --             capabilities = capabilities,
  --             on_attach = on_attach,
  --             settings = {
  --               json = {
  --                 schemas = require("schemastore").json.schemas(),
  --                 validate = { enable = true },
  --               },
  --             },
  --           })
  --         end,
  --
  --         ["gopls"] = function()
  --           lspconfig.gopls.setup({
  --             capabilities = capabilities,
  --             on_attach = on_attach,
  --             settings = {
  --               gopls = {
  --                 gofumpt = true,
  --                 codelenses = {
  --                   gc_details = false,
  --                   generate = true,
  --                   regenerate_cgo = true,
  --                   run_govulncheck = true,
  --                   test = true,
  --                   tidy = true,
  --                   upgrade_dependency = true,
  --                   vendor = true,
  --                 },
  --                 hints = {
  --                   assignVariableTypes = true,
  --                   compositeLiteralFields = true,
  --                   compositeLiteralTypes = true,
  --                   constantValues = true,
  --                   functionTypeParameters = true,
  --                   parameterNames = true,
  --                   rangeVariableTypes = true,
  --                 },
  --                 analyses = {
  --                   fieldalignment = true,
  --                   nilness = true,
  --                   unusedparams = true,
  --                   unusedwrite = true,
  --                   useany = true,
  --                 },
  --                 usePlaceholders = true,
  --                 completeUnimported = true,
  --                 staticcheck = true,
  --                 directoryFilters = { "-.git", "-.vscode", "-.idea", "-.vscode-test", "-node_modules" },
  --                 semanticTokens = false,
  --               },
  --             },
  --           })
  --         end,
  --         ["emmet_language_server"] = function()
  --           lspconfig.emmet_language_server.setup({
  --             capabilities = capabilities,
  --             on_attach = on_attach,
  --             filetypes = { "css", "eruby", "html", "javascript", "javascriptreact", "less", "sass", "scss", "pug", "typescriptreact" },
  --           })
  --         end,
  --       })
  --     end,
  --   },
}
